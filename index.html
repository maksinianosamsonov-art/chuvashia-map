<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>–û–∫—Å–∞–Ω–∞: –ì–µ—Ä–æ–∏–Ω—è –ß–µ–±–æ–∫—Å–∞—Ä</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#0f172a',
            secondary: '#1e293b',
            accent: '#ec4899',
            neon: '#00f5d4',
            glow: '#ff2ea6',
          }
        }
      }
    }
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    body {
      font-family: 'Orbitron', sans-serif;
      background: #0f172a;
      overflow: hidden;
    }
    .neon-text {
      text-shadow: 0 0 10px #ec4899, 0 0 20px #ec4899, 0 0 30px #ec4899;
    }
    .neon-border {
      box-shadow: 0 0 10px #00f5d4, inset 0 0 10px #00f5d4;
    }
    .btn-glow:hover {
      box-shadow: 0 0 15px #ff2ea6;
    }
    canvas {
      display: block;
      background: #0c1427;
    }
    .joystick {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: rgba(30, 41, 59, 0.7);
      border: 2px solid #00f5d4;
      box-shadow: 0 0 10px #00f5d4;
    }
    .joystick-knob {
      position: absolute;
      top: 25px;
      left: 25px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #ec4899;
      box-shadow: 0 0 10px #ec4899;
    }
    .shoot-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(236, 72, 153, 0.7);
      border: 2px solid #ff2ea6;
      box-shadow: 0 0 10px #ff2ea6;
    }
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    .pulse {
      animation: pulse 1.5s infinite;
    }
  </style>
</head>
<body class="text-white overflow-hidden">
  <div id="app" class="w-full h-screen flex flex-col items-center justify-center relative">
    <!-- Main Menu -->
    <div id="menu" class="w-full h-full flex flex-col items-center justify-center space-y-8 p-6 text-center">
      <h1 class="text-4xl neon-text font-bold">–û–∫—Å–∞–Ω–∞ –∏–∑ –ß–µ–±–æ–∫—Å–∞—Ä</h1>
      <p class="text-lg text-neon">–ì–µ—Ä–æ–∏–Ω—è —É–ª–∏—Ü, –¥—Ä–∏—Ñ—Ç –∏ —Å–∫–æ—Ä–æ—Å—Ç–∏!</p>
      
      <div class="space-y-4 w-full max-w-xs">
        <button onclick="startGame('shooter')" class="w-full py-3 px-6 bg-accent rounded-lg font-bold text-white neon-border btn-glow transition">
          üî´ –û–∫—Å–∞–Ω–∞ –≤ –±–æ—é
        </button>
        <button onclick="startGame('drift')" class="w-full py-3 px-6 bg-neon rounded-lg font-bold text-primary neon-border btn-glow transition">
          üèÅ –î—Ä–∏—Ñ—Ç –ø–æ –ß–µ–±–æ–∫—Å–∞—Ä–∞–º
        </button>
        <button onclick="startGame('racing')" class="w-full py-3 px-6 bg-glow rounded-lg font-bold text-white neon-border btn-glow transition">
          üèéÔ∏è –ì–æ–Ω–∫–∏ —Å –¥—Ä—É–∑—å—è–º–∏
        </button>
      </div>

      <div id="records" class="mt-8 text-sm text-gray-400">
        <p>–†–µ–∫–æ—Ä–¥—ã: <span id="record-shooter">0</span> | <span id="record-drift">0</span> | <span id="record-racing">0</span></p>
      </div>
    </div>

    <!-- Game Canvas Container -->
    <div id="game-container" class="hidden w-full h-full relative">
      <canvas id="game-canvas" class="w-full h-full"></canvas>
      <div id="game-ui" class="absolute top-4 left-4 right-4 flex justify-between items-center">
        <div id="score" class="text-2xl font-bold neon-text">0</div>
        <div id="timer" class="text-xl"></div>
        <button onclick="exitGame()" class="text-white bg-red-500 px-3 py-1 rounded neon-border">‚Üê –ù–∞–∑–∞–¥</button>
      </div>
      <!-- Touch Controls (conditionally shown) -->
      <div id="controls" class="absolute inset-0 pointer-events-none"></div>
    </div>
  </div>

  <script type="module">
    // Telegram WebApp Init
    Telegram.WebApp.ready();
    Telegram.WebApp.expand();
    Telegram.WebApp.MainButton.setText('–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç');
    Telegram.WebApp.MainButton.hide();

    // Game state
    const gameState = {
      currentGame: null,
      score: 0,
      records: {
        shooter: parseInt(localStorage.getItem('oxana_shooter') || '0'),
        drift: parseInt(localStorage.getItem('oxana_drift') || '0'),
        racing: parseInt(localStorage.getItem('oxana_racing') || '0')
      }
    };

    // DOM Elements
    const menuEl = document.getElementById('menu');
    const gameContainerEl = document.getElementById('game-container');
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const controlsEl = document.getElementById('controls');
    const recordShooterEl = document.getElementById('record-shooter');
    const recordDriftEl = document.getElementById('record-drift');
    const recordRacingEl = document.getElementById('record-racing');

    // Update records display
    function updateRecords() {
      recordShooterEl.textContent = gameState.records.shooter;
      recordDriftEl.textContent = gameState.records.drift;
      recordRacingEl.textContent = gameState.records.racing;
    }
    updateRecords();

    // Resize canvas
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - 80; // account for UI
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Input state
    const input = {
      left: false,
      right: false,
      up: false,
      down: false,
      shoot: false,
      touch: { x: 0, y: 0, active: false }
    };

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') input.left = true;
      if (e.key === 'ArrowRight') input.right = true;
      if (e.key === 'ArrowUp') input.up = true;
      if (e.key === 'ArrowDown') input.down = true;
      if (e.key === ' ') input.shoot = true;
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') input.left = false;
      if (e.key === 'ArrowRight') input.right = false;
      if (e.key === 'ArrowUp') input.up = false;
      if (e.key === 'ArrowDown') input.down = false;
      if (e.key === ' ') input.shoot = false;
    });

    // Touch controls
    let joystickBase = null;
    let joystickKnob = null;
    let shootBtn = null;

    function createTouchControls() {
      controlsEl.innerHTML = '';
      controlsEl.classList.remove('pointer-events-none');
      
      joystickBase = document.createElement('div');
      joystickBase.className = 'joystick';
      joystickKnob = document.createElement('div');
      joystickKnob.className = 'joystick-knob';
      joystickBase.appendChild(joystickKnob);
      
      shootBtn = document.createElement('div');
      shootBtn.className = 'shoot-btn pulse';
      
      controlsEl.appendChild(joystickBase);
      controlsEl.appendChild(shootBtn);
      
      // Joystick logic
      let isDragging = false;
      const baseRect = { x: 20, y: canvas.height - 120, width: 100, height: 100 };
      
      function updateJoystick(clientX, clientY) {
        const rect = joystickBase.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const deltaX = clientX - centerX;
        const deltaY = clientY - centerY;
        const distance = Math.min(40, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
        const angle = Math.atan2(deltaY, deltaX);
        const posX = Math.cos(angle) * distance;
        const posY = Math.sin(angle) * distance;
        joystickKnob.style.transform = `translate(${posX}px, ${posY}px)`;
        
        input.left = posX < -10;
        input.right = posX > 10;
        input.up = posY < -10;
        input.down = posY > 10;
      }
      
      joystickBase.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDragging = true;
        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
      });
      
      window.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
      });
      
      window.addEventListener('touchend', () => {
        isDragging = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        input.left = input.right = input.up = input.down = false;
      });
      
      // Shoot button
      shootBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        input.shoot = true;
        shootBtn.classList.remove('pulse');
        shootBtn.style.boxShadow = '0 0 20px #ff2ea6';
      });
      
      shootBtn.addEventListener('touchend', () => {
        input.shoot = false;
        shootBtn.classList.add('pulse');
        shootBtn.style.boxShadow = '0 0 10px #ff2ea6';
      });
    }

    // Game exit
    function exitGame() {
      if (gameState.currentGame) {
        // Save score if it's a new record
        const gameKey = gameState.currentGame;
        if (gameState.score > gameState.records[gameKey]) {
          gameState.records[gameKey] = gameState.score;
          localStorage.setItem(`oxana_${gameKey}`, gameState.score.toString());
          updateRecords();
          
          // Show Telegram button to send data
          Telegram.WebApp.MainButton.setText(`–†–µ–∫–æ—Ä–¥: ${gameState.score} –≤ "${gameKey}"`);
          Telegram.WebApp.MainButton.show();
          Telegram.WebApp.MainButton.onClick(() => {
            Telegram.WebApp.sendData(JSON.stringify({ game: gameKey, score: gameState.score }));
            Telegram.WebApp.close();
          });
        }
      }
      
      menuEl.classList.remove('hidden');
      gameContainerEl.classList.add('hidden');
      gameState.currentGame = null;
      gameState.score = 0;
      scoreEl.textContent = '0';
      timerEl.textContent = '';
      controlsEl.innerHTML = '';
      controlsEl.classList.add('pointer-events-none');
      Telegram.WebApp.MainButton.hide();
    }

    // Start game
    window.startGame = function(gameName) {
      menuEl.classList.add('hidden');
      gameContainerEl.classList.remove('hidden');
      gameState.currentGame = gameName;
      gameState.score = 0;
      scoreEl.textContent = '0';
      
      resizeCanvas();
      createTouchControls();
      
      // Initialize specific game
      if (gameName === 'shooter') initShooter();
      else if (gameName === 'drift') initDrift();
      else if (gameName === 'racing') initRacing();
    };

    // Common game loop
    let gameLoop;
    let lastTime = 0;
    
    function startGameLoop(updateFn) {
      if (gameLoop) cancelAnimationFrame(gameLoop);
      lastTime = performance.now();
      
      const loop = (time) => {
        const dt = (time - lastTime) / 1000;
        lastTime = time;
        
        if (gameState.currentGame) {
          updateFn(dt);
          gameLoop = requestAnimationFrame(loop);
        }
      };
      gameLoop = requestAnimationFrame(loop);
    }

    // === MINI-GAME 1: SHOOTER ===
    let shooterState;
    function initShooter() {
      shooterState = {
        player: { x: canvas.width / 2, y: canvas.height / 2, radius: 15, speed: 200, health: 100, reload: 0 },
        bullets: [],
        enemies: [],
        lastEnemySpawn: 0,
        gameOver: false
      };
      
      startGameLoop(updateShooter);
    }
    
    function updateShooter(dt) {
      const s = shooterState;
      if (s.gameOver) return;
      
      // Player movement
      let dx = 0, dy = 0;
      if (input.left) dx -= 1;
      if (input.right) dx += 1;
      if (input.up) dy -= 1;
      if (input.down) dy += 1;
      
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len > 0) {
        dx /= len; dy /= len;
        s.player.x += dx * s.player.speed * dt;
        s.player.y += dy * s.player.speed * dt;
      }
      
      // Keep player in bounds
      s.player.x = Math.max(s.player.radius, Math.min(canvas.width - s.player.radius, s.player.x));
      s.player.y = Math.max(s.player.radius, Math.min(canvas.height - s.player.radius, s.player.y));
      
      // Shooting
      if (input.shoot && s.player.reload <= 0) {
        s.bullets.push({
          x: s.player.x,
          y: s.player.y,
          dx: dx || 0,
          dy: dy || -1,
          speed: 300
        });
        s.player.reload = 0.2; // seconds
      }
      if (s.player.reload > 0) s.player.reload -= dt;
      
      // Spawn enemies
      if (performance.now() - s.lastEnemySpawn > 1000) {
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = Math.random() * canvas.width; y = -20; }
        else if (side === 1) { x = canvas.width + 20; y = Math.random() * canvas.height; }
        else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 20; }
        else { x = -20; y = Math.random() * canvas.height; }
        s.enemies.push({ x, y, radius: 12, speed: 80, health: 1 });
        s.lastEnemySpawn = performance.now();
      }
      
      // Update bullets
      for (let i = s.bullets.length - 1; i >= 0; i--) {
        const b = s.bullets[i];
        b.x += b.dx * b.speed * dt;
        b.y += b.dy * b.speed * dt;
        
        // Remove off-screen bullets
        if (b.x < -10 || b.x > canvas.width + 10 || b.y < -10 || b.y > canvas.height + 10) {
          s.bullets.splice(i, 1);
          continue;
        }
        
        // Bullet-enemy collision
        for (let j = s.enemies.length - 1; j >= 0; j--) {
          const e = s.enemies[j];
          const dx = b.x - e.x;
          const dy = b.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < b.radius + e.radius) {
            s.enemies.splice(j, 1);
            s.bullets.splice(i, 1);
            gameState.score += 10;
            scoreEl.textContent = gameState.score;
            break;
          }
        }
      }
      
      // Update enemies
      for (let i = s.enemies.length - 1; i >= 0; i--) {
        const e = s.enemies[i];
        const dx = s.player.x - e.x;
        const dy = s.player.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0) {
          e.x += (dx / dist) * e.speed * dt;
          e.y += (dy / dist) * e.speed * dt;
        }
        
        // Enemy-player collision
        if (dist < s.player.radius + e.radius) {
          s.player.health -= 10;
          s.enemies.splice(i, 1);
          if (s.player.health <= 0) {
            s.gameOver = true;
            exitGame();
            return;
          }
        }
      }
      
      // Render
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Background (simplified Ch–µ–±–æ–∫sary)
      ctx.fillStyle = '#1a2233';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#2d3748';
      // Fake buildings
      for (let i = 0; i < 10; i++) {
        const w = 30 + Math.random() * 40;
        const h = 50 + Math.random() * 100;
        ctx.fillRect(i * 80 + 20, canvas.height - h, w, h);
      }
      
      // Player
      ctx.fillStyle = '#ec4899';
      ctx.beginPath();
      ctx.arc(s.player.x, s.player.y, s.player.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Bullets
      ctx.fillStyle = '#00f5d4';
      for (const b of s.bullets) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Enemies
      ctx.fillStyle = '#f87171';
      for (const e of s.enemies) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // UI
      ctx.fillStyle = 'white';
      ctx.font = '16px Orbitron';
      ctx.fillText(`HP: ${s.player.health}`, 10, 30);
    }

    // === MINI-GAME 2: DRIFT ===
    let driftState;
    function initDrift() {
      driftState = {
        car: { x: canvas.width / 2, y: canvas.height / 2, angle: 0, speed: 0, maxSpeed: 300 },
        driftFactor: 0,
        score: 0,
        timeLeft: 60,
        lastTime: performance.now(),
        obstacles: [],
        gameOver: false
      };
      
      // Create some obstacles (landmarks)
      for (let i = 0; i < 5; i++) {
        driftState.obstacles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 20 + Math.random() * 30,
          passed: false
        });
      }
      
      startGameLoop(updateDrift);
    }
    
    function updateDrift(dt) {
      const s = driftState;
      if (s.gameOver) return;
      
      // Timer
      const now = performance.now();
      s.timeLeft -= (now - s.lastTime) / 1000;
      s.lastTime = now;
      timerEl.textContent = Math.max(0, Math.floor(s.timeLeft));
      if (s.timeLeft <= 0) {
        gameState.score = Math.floor(s.score);
        exitGame();
        return;
      }
      
      // Controls
      if (input.up) s.car.speed = Math.min(s.car.maxSpeed, s.car.speed + 200 * dt);
      else if (input.down) s.car.speed = Math.max(0, s.car.speed - 200 * dt);
      else s.car.speed *= 0.95;
      
      let turn = 0;
      if (input.left) turn = -2;
      if (input.right) turn = 2;
      
      // Drift physics
      s.car.angle += turn * (s.car.speed / s.car.maxSpeed) * dt;
      const driftAmount = Math.abs(turn) * (s.car.speed / s.car.maxSpeed) * 0.5;
      s.driftFactor = Math.min(1, s.driftFactor + driftAmount * dt);
      s.driftFactor *= 0.98;
      
      // Movement
      s.car.x += Math.sin(s.car.angle) * s.car.speed * dt;
      s.car.y -= Math.cos(s.car.angle) * s.car.speed * dt;
      
      // Keep in bounds (wrap around)
      if (s.car.x < -20) s.car.x = canvas.width + 20;
      if (s.car.x > canvas.width + 20) s.car.x = -20;
      if (s.car.y < -20) s.car.y = canvas.height + 20;
      if (s.car.y > canvas.height + 20) s.car.y = -20;
      
      // Score from drift
      s.score += s.driftFactor * s.car.speed * dt;
      
      // Landmark bonuses
      for (const obs of s.obstacles) {
        if (obs.passed) continue;
        const dx = s.car.x - obs.x;
        const dy = s.car.y - obs.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < obs.radius + 20) {
          obs.passed = true;
          s.score += 100;
        }
      }
      
      // Render
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Night city background
      ctx.fillStyle = '#0c1427';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Stars
      ctx.fillStyle = 'white';
      for (let i = 0; i < 100; i++) {
        ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 1, 1);
      }
      // Landmarks
      ctx.fillStyle = '#ff2ea6';
      for (const obs of s.obstacles) {
        if (!obs.passed) {
          ctx.beginPath();
          ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Car with drift smoke
      ctx.save();
      ctx.translate(s.car.x, s.car.y);
      ctx.rotate(s.car.angle);
      
      // Drift smoke
      if (s.driftFactor > 0.3) {
        ctx.fillStyle = `rgba(255, 255, 255, ${s.driftFactor})`;
        ctx.fillRect(-25, 20, 50, 10 + s.driftFactor * 20);
      }
      
      // Car body
      ctx.fillStyle = s.driftFactor > 0.5 ? '#ec4899' : '#00f5d4';
      ctx.fillRect(-15, -25, 30, 50);
      ctx.restore();
      
      // Score
      gameState.score = Math.floor(s.score);
      scoreEl.textContent = gameState.score;
    }

    // === MINI-GAME 3: RACING ===
    let racingState;
    function initRacing() {
      racingState = {
        playerLane: 1, // 0, 1, 2
        playerY: canvas.height - 100,
        speed: 200,
        obstacles: [],
        rivals: [],
        time: 0,
        score: 0,
        gameOver: false
      };
      
      // Create rivals
      for (let i = 0; i < 2; i++) {
        racingState.rivals.push({
          lane: i === 0 ? 0 : 2,
          y: -100 - i * 300,
          speed: 180 + Math.random() * 40
        });
      }
      
      startGameLoop(updateRacing);
    }
    
    function updateRacing(dt) {
      const s = racingState;
      if (s.gameOver) return;
      
      s.time += dt;
      
      // Lane switching
      if (input.left && s.playerLane > 0) s.playerLane--;
      if (input.right && s.playerLane < 2) s.playerLane++;
      
      // Obstacle spawning
      if (s.time > 2 && s.obstacles.length < 5) {
        s.obstacles.push({
          lane: Math.floor(Math.random() * 3),
          y: -50,
          speed: 250
        });
        s.time = 0;
      }
      
      // Update rivals
      for (const r of s.rivals) {
        r.y += r.speed * dt;
        if (r.y > canvas.height + 50) {
          r.y = -100;
          r.speed = 180 + Math.random() * 40;
        }
      }
      
      // Update obstacles
      for (let i = s.obstacles.length - 1; i >= 0; i--) {
        const obs = s.obstacles[i];
        obs.y += obs.speed * dt;
        if (obs.y > canvas.height + 50) {
          s.obstacles.splice(i, 1);
          s.score += 10;
        }
      }
      
      // Collision detection
      const playerX = 50 + s.playerLane * 100;
      for (const obs of s.obstacles) {
        const obsX = 50 + obs.lane * 100;
        if (Math.abs(playerX - obsX) < 40 && Math.abs(s.playerY - obs.y) < 40) {
          s.gameOver = true;
          gameState.score = Math.floor(s.score);
          exitGame();
          return;
        }
      }
      
      // Render
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Road
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Lane markings
      ctx.strokeStyle = '#00f5d4';
      ctx.setLineDash([20, 20]);
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(50 + i * 100, 0);
        ctx.lineTo(50 + i * 100, canvas.height);
        ctx.stroke();
      }
      ctx.setLineDash([]);
      
      // Player car
      ctx.fillStyle = '#ec4899';
      ctx.fillRect(playerX - 15, s.playerY - 25, 30, 50);
      
      // Rivals
      ctx.fillStyle = '#f87171';
      for (const r of s.rivals) {
        const x = 50 + r.lane * 100;
        ctx.fillRect(x - 15, r.y - 25, 30, 50);
      }
      
      // Obstacles (cones)
      ctx.fillStyle = '#f59e0b';
      for (const obs of s.obstacles) {
        const x = 50 + obs.lane * 100;
        ctx.beginPath();
        ctx.moveTo(x, obs.y - 20);
        ctx.lineTo(x - 10, obs.y + 10);
        ctx.lineTo(x + 10, obs.y + 10);
        ctx.closePath();
        ctx.fill();
      }
      
      gameState.score = Math.floor(s.score);
      scoreEl.textContent = gameState.score;
    }
  </script>
</body>
</html>

