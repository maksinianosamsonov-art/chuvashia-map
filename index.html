<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Приключения Оксаны</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap');

        body {
            font-family: 'Nunito', sans-serif;
            background-color: #0f172a; /* Default, will be changed by JS */
            overflow: hidden;
            touch-action: none;
            transition: background-color 1s ease;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hidden { display: none !important; }
        
        .avatar-pulse {
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
            70% { box-shadow: 0 0 0 15px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        .typing-text::after {
            content: '|';
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }

        /* Стили для фото персонажа */
        .character-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
    </style>
</head>
<body class="text-white h-screen w-screen flex flex-col items-center justify-center relative transition-colors duration-1000">

    <!-- UI: Главное меню -->
    <div id="start-screen" class="glass-panel p-8 flex flex-col items-center justify-center max-w-sm w-[90%] z-20 absolute transition-all duration-500">
        <div class="w-28 h-28 rounded-full border-4 border-white/30 mb-4 avatar-pulse relative overflow-hidden bg-black">
             <!-- 
                ВАЖНО: Чтобы использовать твоё фото, замени src ниже на "image_d88765.jpg" 
                и положи файл рядом с html файлом.
             -->
             <img id="ui-avatar" src="https://api.dicebear.com/9.x/avataaars/svg?seed=Oksana&eyebrows=defaultNatural&hair=longHair&hairColor=2c1b18&skinColor=f8d25c" alt="Оксана" class="character-img">
        </div>
        <h1 id="game-title" class="text-4xl font-black mb-2 text-center text-white drop-shadow-md">Оксана</h1>
        <h2 id="scenario-title" class="text-xl mb-4 font-bold text-gray-200 text-center">...</h2>
        <p id="scenario-desc" class="text-center text-sm text-gray-100 mb-6 leading-relaxed font-semibold shadow-black drop-shadow-sm">
            Загрузка сюжета...
        </p>
        <button onclick="startGame()" class="w-full bg-white text-slate-900 font-bold py-4 px-6 rounded-2xl shadow-xl transform transition active:scale-95 text-lg hover:bg-gray-100">
            НАЧАТЬ ИГРУ
        </button>
    </div>

    <!-- UI: Диалог -->
    <div id="dialog-box" class="hidden glass-panel absolute bottom-12 w-[90%] p-5 z-20 flex items-start gap-4 animate-bounce-in">
        <div class="w-14 h-14 rounded-full bg-white/20 flex-shrink-0 overflow-hidden border-2 border-white">
             <img id="dialog-avatar" src="" class="character-img">
        </div>
        <div class="flex-1">
            <h3 class="text-white font-bold text-xs uppercase mb-1 opacity-80">Оксана говорит:</h3>
            <p id="dialog-text" class="text-base font-bold leading-snug typing-text shadow-black drop-shadow-md"></p>
            <p class="text-xs text-white/60 mt-2 text-right">Нажми, чтобы продолжить...</p>
        </div>
    </div>

    <!-- UI: HUD -->
    <div id="hud" class="hidden absolute top-safe left-0 w-full p-4 flex justify-between z-10 pointer-events-none mt-2">
        <div class="glass-panel px-4 py-2 flex items-center gap-2">
            <span class="text-yellow-300 text-2xl drop-shadow-md">★</span>
            <span id="score" class="font-black text-xl">0</span>
        </div>
        <div class="glass-panel px-4 py-2">
            <span class="text-xs font-bold opacity-80">РЕКОРД: <span id="highscore">0</span></span>
        </div>
    </div>

    <!-- UI: Game Over -->
    <div id="game-over" class="hidden glass-panel p-8 flex flex-col items-center justify-center max-w-sm w-[90%] z-20 absolute">
        <h2 class="text-4xl font-black mb-2 text-red-100 drop-shadow-md">Ой!</h2>
        <p class="text-center text-white mb-6 text-lg">
            Приключение прервалось.<br>
            <span class="text-sm opacity-75">Твой результат:</span> <span id="final-score" class="text-yellow-300 font-bold text-2xl">0</span>
        </p>
        <button onclick="location.reload()" class="w-full bg-white text-slate-900 font-bold py-3 px-6 rounded-xl shadow-lg transform transition active:scale-95">
            Попробовать другой сюжет
        </button>
    </div>

    <canvas id="gameCanvas" class="game-canvas"></canvas>

    <script>
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.ready();

        // --- КОНФИГУРАЦИЯ ИГРОКА (ФОТО) ---
        // Замени ссылку ниже на 'image_d88765.jpg' если файл лежит рядом
        const PLAYER_IMAGE_SRC = "https://api.dicebear.com/9.x/avataaars/svg?seed=Oksana&eyebrows=defaultNatural&hair=longHair&hairColor=2c1b18&skinColor=f8d25c"; 
        
        // --- СЦЕНАРИИ ИГРЫ ---
        const scenarios = [
            {
                id: 'dream',
                title: 'Мир Снов',
                desc: 'Оксана попала в странный сон. Собирай звезды памяти, чтобы проснуться!',
                bgColor: '#0f172a', // Темно-синий
                groundColor: '#1e293b',
                obstacleColor: '#ef4444', // Красный
                starColor: '#fbbf24',
                dialogs: [
                    "Ого, где это я? Все такое странное...",
                    "Я помню этот путь... нужно бежать быстрее!",
                    "Кошмары становятся ближе, страшно!",
                    "Я вижу свет в конце тоннеля!"
                ]
            },
            {
                id: 'forest',
                title: 'Волшебный Лес',
                desc: 'Заколдованный лес полон магии. Собирай светлячков и избегай злых пней!',
                bgColor: '#14532d', // Темно-зеленый
                groundColor: '#365314',
                obstacleColor: '#581c87', // Фиолетовый
                starColor: '#bef264', // Лайм
                dialogs: [
                    "Какой красивый лес, но тут опасно.",
                    "Светлячки показывают мне дорогу.",
                    "Деревья шепчутся... нужно спешить.",
                    "Я почти выбралась из чащи!"
                ]
            },
            {
                id: 'candy',
                title: 'Сладкое Королевство',
                desc: 'Все сделано из сладостей! Собирай леденцы, но не врежься в желейных монстров.',
                bgColor: '#831843', // Розовый/Малиновый
                groundColor: '#9d174d',
                obstacleColor: '#1e1b4b', // Темно-синий
                starColor: '#f472b6', // Розовый светлый
                dialogs: [
                    "Ммм, тут пахнет ванилью!",
                    "Так много конфет, но нельзя останавливаться.",
                    "Желейные блоки очень липкие!",
                    "Сахарная лихорадка! Бегу быстрее!"
                ]
            }
        ];

        // Выбор случайного сценария
        const currentScenario = scenarios[Math.floor(Math.random() * scenarios.length)];

        // Применяем тему к UI
        document.body.style.backgroundColor = currentScenario.bgColor;
        document.getElementById('scenario-title').innerText = currentScenario.title;
        document.getElementById('scenario-desc').innerText = currentScenario.desc;
        document.getElementById('ui-avatar').src = PLAYER_IMAGE_SRC;
        document.getElementById('dialog-avatar').src = PLAYER_IMAGE_SRC;

        // --- ИГРОВОЙ ДВИЖОК ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        const resize = () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        };
        window.addEventListener('resize', resize);
        resize();

        // Загрузка спрайта игрока
        const playerSprite = new Image();
        playerSprite.src = PLAYER_IMAGE_SRC;

        // Переменные состояния
        let gameActive = false;
        let score = 0;
        let highScore = localStorage.getItem('oksana_hs_v2') || 0;
        document.getElementById('highscore').innerText = highScore;
        let frame = 0;
        let gameSpeed = 6; // Чуть быстрее старт
        
        // Классы
        class Player {
            constructor() {
                this.size = 50; // Размер персонажа
                this.x = 40;
                this.y = height - 150;
                this.dy = 0;
                this.jumpPower = -17; // Сильнее прыжок
                this.gravity = 0.9;
                this.isJumping = false;
                this.groundY = height - 100;
                this.rotation = 0;
            }

            update() {
                // Физика
                this.dy += this.gravity;
                this.y += this.dy;

                // Пол
                if (this.y + this.size > this.groundY) {
                    this.y = this.groundY - this.size;
                    this.dy = 0;
                    this.isJumping = false;
                    this.rotation = 0;
                } else {
                    // Вращение в прыжке для динамики
                    this.rotation += 0.1;
                }
            }

            jump() {
                if (!this.isJumping) {
                    this.dy = this.jumpPower;
                    this.isJumping = true;
                    if(tg.HapticFeedback) tg.HapticFeedback.impactOccurred('medium');
                }
            }

            draw() {
                ctx.save();
                // Центр вращения - центр персонажа
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                
                // Если бежит - покачиваемся, если прыгает - вращаем немного
                if(this.isJumping) {
                    // ctx.rotate(this.rotation); // Можно включить для сальто
                    ctx.rotate(-0.2); // Просто наклон
                } else {
                    ctx.rotate(Math.sin(frame * 0.15) * 0.1);
                }

                // Рисуем круглое фото (маска)
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip();
                
                // Рисуем само изображение
                if (playerSprite.complete) {
                    ctx.drawImage(playerSprite, -this.size/2, -this.size/2, this.size, this.size);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }

                // Обводка
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.restore();
            }
        }

        class Obstacle {
            constructor() {
                this.w = 40 + Math.random() * 20;
                this.h = 40 + Math.random() * 40;
                this.x = width;
                this.y = (height - 100) - this.h;
                this.color = currentScenario.obstacleColor;
                this.markedForDeletion = false;
            }

            update() {
                this.x -= gameSpeed;
                if (this.x + this.w < 0) this.markedForDeletion = true;
            }

            draw() {
                ctx.fillStyle = this.color;
                // Небольшое свечение
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                
                // Рисуем с закругленными краями
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.w, this.h, 8);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
        }

        class Star {
            constructor() {
                this.size = 12; // Радиус
                this.x = width;
                this.y = (height - 100) - 50 - Math.random() * 120; // Разная высота
                this.markedForDeletion = false;
                this.angle = 0;
            }

            update() {
                this.x -= gameSpeed;
                this.angle += 0.05;
                if (this.x < -50) this.markedForDeletion = true;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = currentScenario.starColor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = currentScenario.starColor;

                // Рисуем звезду
                ctx.beginPath();
                for(let i = 0; i < 5; i++){
                    ctx.lineTo(Math.cos((18 + i * 72) * 0.0174533) * this.size, 
                               Math.sin((18 + i * 72) * 0.0174533) * this.size);
                    ctx.lineTo(Math.cos((54 + i * 72) * 0.0174533) * (this.size/2), 
                               Math.sin((54 + i * 72) * 0.0174533) * (this.size/2));
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
                ctx.shadowBlur = 0;
            }
        }

        // Объекты
        let player = new Player();
        let obstacles = [];
        let stars = [];
        let obstacleTimer = 0;
        let starTimer = 0;

        // Управление
        const handleInput = () => {
            const dialog = document.getElementById('dialog-box');
            if (!dialog.classList.contains('hidden')) {
                closeDialog();
                return;
            }
            if (gameActive) player.jump();
        };

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') handleInput();
        });
        window.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            handleInput();
        }, {passive: false});
        window.addEventListener('mousedown', handleInput);

        // Логика Диалогов
        function showDialog(text) {
            gameActive = false; 
            const dialog = document.getElementById('dialog-box');
            const textEl = document.getElementById('dialog-text');
            dialog.classList.remove('hidden');
            
            textEl.innerHTML = '';
            let i = 0;
            const type = () => {
                if (i < text.length) {
                    textEl.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(type, 25);
                }
            };
            type();
        }

        function closeDialog() {
            document.getElementById('dialog-box').classList.add('hidden');
            gameActive = true;
            gameSpeed += 0.8; // Ускоряемся после диалога
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('game-over').classList.add('hidden');
            
            player = new Player();
            obstacles = [];
            stars = [];
            score = 0;
            gameSpeed = 6;
            document.getElementById('score').innerText = '0';
            
            gameActive = true;
            setTimeout(() => showDialog(currentScenario.dialogs[0]), 300);
            animate();
        }

        function gameOver() {
            gameActive = false;
            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('error');
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('oksana_hs_v2', highScore);
                document.getElementById('highscore').innerText = highScore;
            }
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
        }

        function animate() {
            if (!gameActive && document.getElementById('dialog-box').classList.contains('hidden')) return; 

            ctx.clearRect(0, 0, width, height);

            // Отрисовка фона (земля)
            ctx.fillStyle = currentScenario.groundColor;
            ctx.fillRect(0, height - 100, width, 100);
            
            // Декоративная линия земли
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(0, height - 100, width, 4);

            if (gameActive) {
                frame++;

                // Генерация препятствий
                if (obstacleTimer > 120 - (gameSpeed * 1.5) + Math.random() * 60) {
                    obstacles.push(new Obstacle());
                    obstacleTimer = 0;
                } else obstacleTimer++;

                // Генерация звезд
                if (starTimer > 60 + Math.random() * 50) {
                    stars.push(new Star());
                    starTimer = 0;
                } else starTimer++;

                player.update();
                [...obstacles, ...stars].forEach(o => o.update());

                // Удаление старых объектов
                obstacles = obstacles.filter(o => !o.markedForDeletion);
                stars = stars.filter(s => !s.markedForDeletion);

                // Коллизии
                obstacles.forEach(obs => {
                    // Простая AABB коллизия с отступом (hitbox меньше спрайта)
                    if (
                        player.x + 10 < obs.x + obs.w &&
                        player.x + player.size - 10 > obs.x &&
                        player.y + 10 < obs.y + obs.h &&
                        player.y + player.size > obs.y
                    ) {
                        gameOver();
                    }
                });

                stars.forEach(star => {
                    if (!star.markedForDeletion &&
                        player.x < star.x + star.size &&
                        player.x + player.size > star.x &&
                        player.y < star.y + star.size &&
                        player.y + player.size > star.y
                    ) {
                        star.markedForDeletion = true;
                        score += 10;
                        document.getElementById('score').innerText = score;
                        if (tg.HapticFeedback) tg.HapticFeedback.impactOccurred('light');

                        // Триггеры сюжета
                        if (score === 50) showDialog(currentScenario.dialogs[1]);
                        if (score === 150) showDialog(currentScenario.dialogs[2]);
                        if (score === 300) showDialog(currentScenario.dialogs[3]);
                    }
                });
            }

            // Отрисовка
            stars.forEach(s => s.draw());
            obstacles.forEach(o => o.draw());
            player.draw();

            if(gameActive || !document.getElementById('dialog-box').classList.contains('hidden')) {
                requestAnimationFrame(animate);
            }
        }
    </script>
</body>
</html>
