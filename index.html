<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>–û–∫—Å–∞–Ω–∞ –∏–∑ –ß–µ–±–æ–∫—Å–∞—Ä</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#0f172a',
            secondary: '#1e293b',
            accent: '#ec4899',
            neon: '#00f5d4',
            glow: '#ff2ea6',
          },
          fontFamily: {
            orbitron: ['Orbitron', 'sans-serif']
          }
        }
      }
    }
  </script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      background: #0f172a;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }
    .neon-text {
      text-shadow: 0 0 8px #ec4899, 0 0 16px #ec4899;
    }
    .neon-border {
      box-shadow: 0 0 8px #00f5d4, inset 0 0 8px #00f5d4;
    }
    .btn-glow {
      transition: all 0.2s ease;
    }
    .btn-glow:hover {
      box-shadow: 0 0 16px #ff2ea6;
      transform: scale(1.03);
    }
    canvas {
      display: block;
      background: #0c1427;
      width: 100%;
      height: 100%;
    }
    .joystick {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: rgba(30, 41, 59, 0.6);
      border: 2px solid #00f5d4;
      box-shadow: 0 0 10px #00f5d4;
      touch-action: none;
    }
    .joystick-knob {
      position: absolute;
      top: 25px;
      left: 25px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #ec4899;
      box-shadow: 0 0 10px #ec4899;
      touch-action: none;
    }
    .shoot-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(236, 72, 153, 0.7);
      border: 2px solid #ff2ea6;
      box-shadow: 0 0 10px #ff2ea6;
      touch-action: none;
    }
    @keyframes pulse {
      0% { opacity: 0.7; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
      100% { opacity: 0.7; transform: scale(1); }
    }
    .pulse {
      animation: pulse 2s infinite;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body class="text-white overflow-hidden">
  <div id="app" class="w-full h-screen flex flex-col relative">
    <!-- Main Menu -->
    <div id="menu" class="w-full h-full flex flex-col items-center justify-center space-y-8 p-6 text-center">
      <div class="text-center">
        <h1 class="text-4xl md:text-5xl font-bold neon-text mb-2">–û–∫—Å–∞–Ω–∞ –∏–∑ –ß–µ–±–æ–∫—Å–∞—Ä</h1>
        <p class="text-lg text-neon">25 –ª–µ—Ç ¬∑ –ú–∞—Å—Ç–µ—Ä —É–ª–∏—Ü ¬∑ –ö–æ—Ä–æ–ª–µ–≤–∞ –¥—Ä–∏—Ñ—Ç–∞</p>
      </div>
      
      <div class="space-y-4 w-full max-w-xs">
        <button onclick="startGame('shooter')" class="w-full py-4 px-6 bg-accent rounded-xl font-bold text-white neon-border btn-glow transition text-lg">
          üî´ –û–∫—Å–∞–Ω–∞ –≤ –±–æ—é
        </button>
        <button onclick="startGame('drift')" class="w-full py-4 px-6 bg-neon rounded-xl font-bold text-primary neon-border btn-glow transition text-lg">
          üèÅ –î—Ä–∏—Ñ—Ç –ø–æ –ß–µ–±–æ–∫—Å–∞—Ä–∞–º
        </button>
        <button onclick="startGame('racing')" class="w-full py-4 px-6 bg-glow rounded-xl font-bold text-white neon-border btn-glow transition text-lg">
          üèéÔ∏è –ì–æ–Ω–∫–∏ —Å –¥—Ä—É–∑—å—è–º–∏
        </button>
      </div>

      <div id="records" class="mt-8 text-sm text-gray-400 bg-secondary/50 p-4 rounded-lg">
        <p class="font-mono">–õ–£–ß–®–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´</p>
        <p>üî´ <span id="record-shooter">0</span> | üèÅ <span id="record-drift">0</span> | üèéÔ∏è <span id="record-racing">0</span></p>
      </div>
      
      <div class="text-xs text-gray-500 mt-4">
        –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: —Å–µ–Ω—Å–æ—Ä–Ω–æ–µ –∏–ª–∏ –∫–ª–∞–≤–∏—à–∏-—Å—Ç—Ä–µ–ª–∫–∏
      </div>
    </div>

    <!-- Game Canvas Container -->
    <div id="game-container" class="hidden w-full h-full relative">
      <canvas id="game-canvas"></canvas>
      <div id="game-ui" class="absolute top-4 left-4 right-4 flex justify-between items-center px-4">
        <div id="score" class="text-2xl font-bold neon-text">0</div>
        <div id="timer" class="text-xl text-neon font-mono"></div>
        <button onclick="exitGame()" class="text-white bg-red-500/80 px-4 py-2 rounded-lg neon-border font-bold">
          ‚Üê –ú–µ–Ω—é
        </button>
      </div>
      <div id="controls" class="absolute inset-0 pointer-events-none"></div>
    </div>
  </div>

  <script>
    // Telegram WebApp initialization
    if (window.Telegram && Telegram.WebApp) {
      Telegram.WebApp.ready();
      Telegram.WebApp.expand();
      Telegram.WebApp.setHeaderColor('#0f172a');
      Telegram.WebApp.setBackgroundColor('#0f172a');
      Telegram.WebApp.MainButton.setText('–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∫–æ—Ä–¥');
      Telegram.WebApp.MainButton.hide();
    }

    // Game state management
    const gameState = {
      currentGame: null,
      score: 0,
      records: {
        shooter: parseInt(localStorage.getItem('oxana_shooter') || '0'),
        drift: parseInt(localStorage.getItem('oxana_drift') || '0'),
        racing: parseInt(localStorage.getItem('oxana_racing') || '0')
      }
    };

    // DOM Elements
    const menuEl = document.getElementById('menu');
    const gameContainerEl = document.getElementById('game-container');
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const controlsEl = document.getElementById('controls');
    const recordElements = {
      shooter: document.getElementById('record-shooter'),
      drift: document.getElementById('record-drift'),
      racing: document.getElementById('record-racing')
    };

    // Update records display
    function updateRecords() {
      recordElements.shooter.textContent = gameState.records.shooter.toLocaleString();
      recordElements.drift.textContent = gameState.records.drift.toLocaleString();
      recordElements.racing.textContent = gameState.records.racing.toLocaleString();
    }
    updateRecords();

    // Canvas resize handler
    function resizeCanvas() {
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;
      canvas.width = displayWidth;
      canvas.height = displayHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Input state
    const input = {
      left: false,
      right: false,
      up: false,
      down: false,
      shoot: false,
      touchX: 0,
      touchY: 0
    };

    // Keyboard event handlers
    window.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowLeft': input.left = true; break;
        case 'ArrowRight': input.right = true; break;
        case 'ArrowUp': input.up = true; break;
        case 'ArrowDown': input.down = true; break;
        case ' ': input.shoot = true; break;
      }
    });

    window.addEventListener('keyup', (e) => {
      switch(e.key) {
        case 'ArrowLeft': input.left = false; break;
        case 'ArrowRight': input.right = false; break;
        case 'ArrowUp': input.up = false; break;
        case 'ArrowDown': input.down = false; break;
        case ' ': input.shoot = false; break;
      }
    });

    // Touch control creation
    function createTouchControls() {
      controlsEl.innerHTML = '';
      controlsEl.classList.remove('pointer-events-none');
      
      // Joystick
      const joystickBase = document.createElement('div');
      joystickBase.className = 'joystick';
      const joystickKnob = document.createElement('div');
      joystickKnob.className = 'joystick-knob';
      joystickBase.appendChild(joystickKnob);
      
      // Shoot button
      const shootBtn = document.createElement('div');
      shootBtn.className = 'shoot-btn pulse';
      
      controlsEl.appendChild(joystickBase);
      controlsEl.appendChild(shootBtn);
      
      // Joystick interaction
      let isDragging = false;
      let baseRect = null;
      
      function getBaseRect() {
        return {
          x: 20,
          y: canvas.height - 120,
          width: 100,
          height: 100
        };
      }
      
      function updateJoystickPosition(clientX, clientY) {
        baseRect = baseRect || getBaseRect();
        const centerX = baseRect.x + baseRect.width / 2;
        const centerY = baseRect.y + baseRect.height / 2;
        const deltaX = clientX - centerX;
        const deltaY = clientY - centerY;
        const distance = Math.min(40, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
        const angle = Math.atan2(deltaY, deltaX);
        const posX = Math.cos(angle) * distance;
        const posY = Math.sin(angle) * distance;
        
        joystickKnob.style.transform = `translate(${posX}px, ${posY}px)`;
        
        input.left = posX < -10;
        input.right = posX > 10;
        input.up = posY < -10;
        input.down = posY > 10;
      }
      
      joystickBase.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDragging = true;
        baseRect = getBaseRect();
        updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
      });
      
      window.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
      });
      
      window.addEventListener('touchend', () => {
        isDragging = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        input.left = input.right = input.up = input.down = false;
      });
      
      // Shoot button interaction
      let isShooting = false;
      shootBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isShooting) return;
        isShooting = true;
        input.shoot = true;
        shootBtn.classList.remove('pulse');
        shootBtn.style.transform = 'scale(0.95)';
        shootBtn.style.boxShadow = '0 0 20px #ff2ea6';
      });
      
      shootBtn.addEventListener('touchend', () => {
        input.shoot = false;
        isShooting = false;
        shootBtn.classList.add('pulse');
        shootBtn.style.transform = 'scale(1)';
        shootBtn.style.boxShadow = '0 0 10px #ff2ea6';
      });
    }

    // Exit game function
    function exitGame() {
      if (gameState.currentGame) {
        const gameKey = gameState.currentGame;
        if (gameState.score > gameState.records[gameKey]) {
          gameState.records[gameKey] = gameState.score;
          localStorage.setItem(`oxana_${gameKey}`, gameState.score.toString());
          updateRecords();
          
          if (window.Telegram && Telegram.WebApp) {
            Telegram.WebApp.MainButton.setText(`üî• –ù–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥: ${gameState.score} –≤ "${gameKey}"`);
            Telegram.WebApp.MainButton.show();
            Telegram.WebApp.MainButton.onClick(() => {
              Telegram.WebApp.sendData(JSON.stringify({ 
                game: gameKey, 
                score: gameState.score,
                name: '–û–∫—Å–∞–Ω–∞ –∏–∑ –ß–µ–±–æ–∫—Å–∞—Ä'
              }));
              Telegram.WebApp.close();
            });
          }
        }
      }
      
      menuEl.classList.remove('hidden');
      gameContainerEl.classList.add('hidden');
      gameState.currentGame = null;
      gameState.score = 0;
      scoreEl.textContent = '0';
      timerEl.textContent = '';
      controlsEl.innerHTML = '';
      controlsEl.classList.add('pointer-events-none');
      
      if (window.Telegram && Telegram.WebApp) {
        Telegram.WebApp.MainButton.hide();
      }
    }

    // Start game function
    window.startGame = function(gameName) {
      menuEl.classList.add('hidden');
      gameContainerEl.classList.remove('hidden');
      gameState.currentGame = gameName;
      gameState.score = 0;
      scoreEl.textContent = '0';
      
      resizeCanvas();
      createTouchControls();
      
      // Reset input
      input.left = input.right = input.up = input.down = input.shoot = false;
      
      // Initialize specific game
      if (gameName === 'shooter') initShooterGame();
      else if (gameName === 'drift') initDriftGame();
      else if (gameName === 'racing') initRacingGame();
    };

    // Game loop management
    let animationFrameId = null;
    let lastTimestamp = 0;
    
    function startGameLoop(updateFunction) {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      lastTimestamp = performance.now();
      
      const gameLoop = (timestamp) => {
        const deltaTime = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;
        
        if (gameState.currentGame) {
          updateFunction(deltaTime);
          animationFrameId = requestAnimationFrame(gameLoop);
        }
      };
      
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // === SHOOTER GAME ===
    let shooterGame = null;
    
    function initShooterGame() {
      shooterGame = {
        player: {
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: 18,
          speed: 250,
          health: 100,
          maxHealth: 100,
          reloadTime: 0,
          maxReload: 0.25
        },
        bullets: [],
        enemies: [],
        particles: [],
        lastEnemySpawn: 0,
        enemySpawnInterval: 800,
        gameOver: false
      };
      
      startGameLoop(updateShooterGame);
    }
    
    function updateShooterGame(deltaTime) {
      if (shooterGame.gameOver) return;
      
      const game = shooterGame;
      
      // Player movement
      let moveX = 0, moveY = 0;
      if (input.left) moveX -= 1;
      if (input.right) moveX += 1;
      if (input.up) moveY -= 1;
      if (input.down) moveY += 1;
      
      const moveLength = Math.sqrt(moveX * moveX + moveY * moveY);
      if (moveLength > 0) {
        moveX /= moveLength;
        moveY /= moveLength;
        game.player.x += moveX * game.player.speed * deltaTime;
        game.player.y += moveY * game.player.speed * deltaTime;
      }
      
      // Boundary constraints
      game.player.x = Math.max(game.player.radius, Math.min(canvas.width - game.player.radius, game.player.x));
      game.player.y = Math.max(game.player.radius, Math.min(canvas.height - game.player.radius, game.player.y));
      
      // Shooting
      if (input.shoot && game.player.reloadTime <= 0) {
        const shootDirX = moveX || 0;
        const shootDirY = moveY || -1;
        game.bullets.push({
          x: game.player.x,
          y: game.player.y,
          dirX: shootDirX,
          dirY: shootDirY,
          speed: 400,
          radius: 4
        });
        game.player.reloadTime = game.player.maxReload;
      }
      if (game.player.reloadTime > 0) {
        game.player.reloadTime -= deltaTime;
      }
      
      // Enemy spawning
      if (performance.now() - game.lastEnemySpawn > game.enemySpawnInterval) {
        const side = Math.floor(Math.random() * 4);
        let spawnX, spawnY;
        switch(side) {
          case 0: // top
            spawnX = Math.random() * canvas.width;
            spawnY = -30;
            break;
          case 1: // right
            spawnX = canvas.width + 30;
            spawnY = Math.random() * canvas.height;
            break;
          case 2: // bottom
            spawnX = Math.random() * canvas.width;
            spawnY = canvas.height + 30;
            break;
          case 3: // left
            spawnX = -30;
            spawnY = Math.random() * canvas.height;
            break;
        }
        game.enemies.push({
          x: spawnX,
          y: spawnY,
          radius: 15,
          speed: 80 + Math.random() * 40,
          health: 1
        });
        game.lastEnemySpawn = performance.now();
        game.enemySpawnInterval = Math.max(300, game.enemySpawnInterval * 0.98);
      }
      
      // Update bullets
      for (let i = game.bullets.length - 1; i >= 0; i--) {
        const bullet = game.bullets[i];
        bullet.x += bullet.dirX * bullet.speed * deltaTime;
        bullet.y += bullet.dirY * bullet.speed * deltaTime;
        
        // Remove off-screen bullets
        if (bullet.x < -50 || bullet.x > canvas.width + 50 || 
            bullet.y < -50 || bullet.y > canvas.height + 50) {
          game.bullets.splice(i, 1);
          continue;
        }
        
        // Bullet-enemy collision
        for (let j = game.enemies.length - 1; j >= 0; j--) {
          const enemy = game.enemies[j];
          const dx = bullet.x - enemy.x;
          const dy = bullet.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < bullet.radius + enemy.radius) {
            // Create hit particles
            for (let k = 0; k < 8; k++) {
              game.particles.push({
                x: enemy.x,
                y: enemy.y,
                vx: (Math.random() - 0.5) * 100,
                vy: (Math.random() - 0.5) * 100,
                life: 1.0,
                decay: 2.0
              });
            }
            game.enemies.splice(j, 1);
            game.bullets.splice(i, 1);
            gameState.score += 25;
            scoreEl.textContent = gameState.score.toLocaleString();
            break;
          }
        }
      }
      
      // Update enemies
      for (let i = game.enemies.length - 1; i >= 0; i--) {
        const enemy = game.enemies[i];
        const dx = game.player.x - enemy.x;
        const dy = game.player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > 0) {
          enemy.x += (dx / distance) * enemy.speed * deltaTime;
          enemy.y += (dy / distance) * enemy.speed * deltaTime;
        }
        
        // Enemy-player collision
        if (distance < game.player.radius + enemy.radius) {
          game.player.health -= 15;
          game.enemies.splice(i, 1);
          // Create collision particles
          for (let k = 0; k < 12; k++) {
            game.particles.push({
              x: game.player.x,
              y: game.player.y,
              vx: (Math.random() - 0.5) * 150,
              vy: (Math.random() - 0.5) * 150,
              life: 1.0,
              decay: 3.0,
              color: '#f87171'
            });
          }
          if (game.player.health <= 0) {
            game.gameOver = true;
            setTimeout(() => exitGame(), 1000);
          }
        }
      }
      
      // Update particles
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx * deltaTime;
        p.y += p.vy * deltaTime;
        p.life -= p.decay * deltaTime;
        if (p.life <= 0) {
          game.particles.splice(i, 1);
        }
      }
      
      // Render everything
      renderShooterGame();
    }
    
    function renderShooterGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Background - stylized Cheboksary
      ctx.fillStyle = '#1a2233';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Simple cityscape
      ctx.fillStyle = '#2d3748';
      const buildingCount = Math.floor(canvas.width / 40);
      for (let i = 0; i < buildingCount; i++) {
        const width = 25 + Math.random() * 20;
        const height = 80 + Math.random() * 120;
        const x = i * 40 + 10;
        const y = canvas.height - height;
        ctx.fillRect(x, y, width, height);
        
        // Windows
        ctx.fillStyle = '#00f5d4';
        for (let wy = y + 10; wy < y + height; wy += 20) {
          for (let wx = x + 5; wx < x + width; wx += 12) {
            if (Math.random() > 0.3) {
              ctx.fillRect(wx, wy, 6, 10);
            }
          }
        }
        ctx.fillStyle = '#2d3748';
      }
      
      // Particles
      for (const p of shooterGame.particles) {
        const alpha = p.life;
        ctx.fillStyle = p.color || `rgba(236, 72, 153, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Bullets
      ctx.fillStyle = '#00f5d4';
      for (const bullet of shooterGame.bullets) {
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.bullet?.y || bullet.y, bullet.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Enemies
      ctx.fillStyle = '#f87171';
      for (const enemy of shooterGame.enemies) {
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Player
      ctx.fillStyle = '#ec4899';
      ctx.beginPath();
      ctx.arc(shooterGame.player.x, shooterGame.player.y, shooterGame.player.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Player health bar
      const healthBarWidth = 100;
      const healthPercent = shooterGame.player.health / shooterGame.player.maxHealth;
      ctx.fillStyle = '#450a0a';
      ctx.fillRect(shooterGame.player.x - healthBarWidth/2, shooterGame.player.y - 30, healthBarWidth, 8);
      ctx.fillStyle = healthPercent > 0.5 ? '#10b981' : healthPercent > 0.25 ? '#f59e0b' : '#ef4444';
      ctx.fillRect(shooterGame.player.x - healthBarWidth/2, shooterGame.player.y - 30, healthBarWidth * healthPercent, 8);
    }

    // === DRIFT GAME ===
    let driftGame = null;
    
    function initDriftGame() {
      driftGame = {
        car: {
          x: canvas.width / 2,
          y: canvas.height / 2,
          angle: 0,
          speed: 0,
          maxSpeed: 350,
          acceleration: 400,
          friction: 0.95
        },
        driftAngle: 0,
        driftIntensity: 0,
        score: 0,
        timeLeft: 60,
        lastTimeUpdate: performance.now(),
        landmarks: [],
        trail: [],
        gameOver: false
      };
      
      // Create landmarks (Cheboksary landmarks)
      const landmarks = [
        { name: '–ì–≠–°', x: 100, y: 100, radius: 25 },
        { name: '–ú–æ—Å—Ç', x: canvas.width - 100, y: 150, radius: 20 },
        { name: '–ü–ª–æ—â–∞–¥—å', x: canvas.width / 2, y: canvas.height - 100, radius: 30 },
        { name: '–ë—É–ª—å–≤–∞—Ä', x: 200, y: canvas.height - 150, radius: 22 }
      ];
      driftGame.landmarks = landmarks;
      
      startGameLoop(updateDriftGame);
    }
    
    function updateDriftGame(deltaTime) {
      if (driftGame.gameOver) return;
      
      const game = driftGame;
      
      // Timer update
      const now = performance.now();
      game.timeLeft -= (now - game.lastTimeUpdate) / 1000;
      game.lastTimeUpdate = now;
      timerEl.textContent = Math.max(0, Math.floor(game.timeLeft));
      
      if (game.timeLeft <= 0) {
        gameState.score = Math.floor(game.score);
        setTimeout(() => exitGame(), 500);
        return;
      }
      
      // Car controls
      if (input.up) {
        game.car.speed = Math.min(game.car.maxSpeed, game.car.speed + game.car.acceleration * deltaTime);
      } else if (input.down) {
        game.car.speed = Math.max(0, game.car.speed - game.car.acceleration * deltaTime);
      } else {
        game.car.speed *= Math.pow(game.car.friction, deltaTime * 60);
      }
      
      let steering = 0;
      if (input.left) steering = -3;
      if (input.right) steering = 3;
      
      // Drift physics
      const turnSpeed = steering * (game.car.speed / game.car.maxSpeed) * 2;
      game.car.angle += turnSpeed * deltaTime;
      game.driftAngle = turnSpeed * deltaTime * 20;
      game.driftIntensity = Math.min(1, game.driftIntensity + Math.abs(turnSpeed) * deltaTime * 0.8);
      game.driftIntensity *= 0.97;
      
      // Movement
      game.car.x += Math.sin(game.car.angle) * game.car.speed * deltaTime;
      game.car.y -= Math.cos(game.car.angle) * game.car.speed * deltaTime;
      
      // Screen wrapping
      if (game.car.x < -50) game.car.x = canvas.width + 50;
      if (game.car.x > canvas.width + 50) game.car.x = -50;
      if (game.car.y < -50) game.car.y = canvas.height + 50;
      if (game.car.y > canvas.height + 50) game.car.y = -50;
      
      // Add to trail for visual effect
      if (game.car.speed > 50) {
        game.trail.push({
          x: game.car.x - Math.sin(game.car.angle) * 30,
          y: game.car.y + Math.cos(game.car.angle) * 30,
          intensity: game.driftIntensity,
          life: 1.0
        });
        if (game.trail.length > 20) game.trail.shift();
      }
      
      // Score calculation
      game.score += game.driftIntensity * game.car.speed * deltaTime * 0.1;
      
      // Landmark bonuses
      for (const landmark of game.landmarks) {
        const dx = game.car.x - landmark.x;
        const dy = game.car.y - landmark.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < landmark.radius + 25 && game.car.speed > 100) {
          game.score += 50;
          landmark.collected = true;
          setTimeout(() => { landmark.collected = false; }, 2000);
        }
      }
      
      // Render
      renderDriftGame();
    }
    
    function renderDriftGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Night sky background
      ctx.fillStyle = '#0c1427';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Stars
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      for (let i = 0; i < 80; i++) {
        const x = (i * 37) % canvas.width;
        const y = (i * 73) % canvas.height;
        ctx.fillRect(x, y, 1.5, 1.5);
      }
      
      // Landmarks
      for (const landmark of driftGame.landmarks) {
        ctx.fillStyle = landmark.collected ? '#10b981' : '#ff2ea6';
        ctx.beginPath();
        ctx.arc(landmark.x, landmark.y, landmark.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = '12px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText(landmark.name, landmark.x, landmark.y + landmark.radius + 20);
      }
      
      // Drift trail
      for (let i = 0; i < driftGame.trail.length; i++) {
        const point = driftGame.trail[i];
        const alpha = point.life * point.intensity;
        if (alpha > 0) {
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.beginPath();
          ctx.arc(point.x, point.y, 2 + i * 0.3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Car
      ctx.save();
      ctx.translate(driftGame.car.x, driftGame.car.y);
      ctx.rotate(driftGame.car.angle);
      
      // Car body
      const carColor = driftGame.driftIntensity > 0.6 ? '#ec4899' : '#00f5d4';
      ctx.fillStyle = carColor;
      ctx.fillRect(-12, -25, 24, 45);
      
      // Windows
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(-8, -20, 16, 15);
      
      ctx.restore();
      
      // Score display
      gameState.score = Math.floor(driftGame.score);
      scoreEl.textContent = gameState.score.toLocaleString();
    }

    // === RACING GAME ===
    let racingGame = null;
    
    function initRacingGame() {
      racingGame = {
        lanes: 3,
        laneWidth: canvas.width / 3,
        playerLane: 1,
        playerY: canvas.height - 120,
        speed: 220,
        rivals: [],
        obstacles: [],
        roadOffset: 0,
        score: 0,
        lastObstacle: 0,
        obstacleInterval: 1500,
        gameOver: false
      };
      
      // Create rivals
      for (let i = 0; i < 2; i++) {
        racingGame.rivals.push({
          lane: i === 0 ? 0 : 2,
          y: -100 - i * 250,
          speed: 180 + Math.random() * 30,
          color: i === 0 ? '#f59e0b' : '#8b5cf6'
        });
      }
      
      startGameLoop(updateRacingGame);
    }
    
    function updateRacingGame(deltaTime) {
      if (racingGame.gameOver) return;
      
      const game = racingGame;
      
      // Lane switching
      if (input.left && game.playerLane > 0) {
        game.playerLane--;
      }
      if (input.right && game.playerLane < game.lanes - 1) {
        game.playerLane++;
      }
      
      // Road scrolling
      game.roadOffset += game.speed * deltaTime;
      
      // Obstacle spawning
      if (performance.now() - game.lastObstacle > game.obstacleInterval) {
        game.obstacles.push({
          lane: Math.floor(Math.random() * game.lanes),
          y: -50,
          width: 30,
          height: 40,
          speed: 250 + Math.random() * 50
        });
        game.lastObstacle = performance.now();
        game.obstacleInterval = Math.max(800, game.obstacleInterval * 0.97);
      }
      
      // Update rivals
      for (const rival of game.rivals) {
        rival.y += rival.speed * deltaTime;
        if (rival.y > canvas.height + 100) {
          rival.y = -100;
          rival.speed = 180 + Math.random() * 30;
        }
      }
      
      // Update obstacles
      for (let i = game.obstacles.length - 1; i >= 0; i--) {
        const obs = game.obstacles[i];
        obs.y += obs.speed * deltaTime;
        if (obs.y > canvas.height + 100) {
          game.obstacles.splice(i, 1);
          game.score += 15;
        }
      }
      
      // Collision detection
      const playerX = game.laneWidth * game.playerLane + game.laneWidth / 2;
      const playerWidth = 35;
      const playerHeight = 60;
      
      // Check rivals
      for (const rival of game.rivals) {
        const rivalX = game.laneWidth * rival.lane + game.laneWidth / 2;
        const dx = Math.abs(playerX - rivalX);
        const dy = Math.abs(game.playerY - rival.y);
        if (dx < playerWidth && dy < playerHeight) {
          game.gameOver = true;
          gameState.score = Math.floor(game.score);
          setTimeout(() => exitGame(), 1000);
          return;
        }
      }
      
      // Check obstacles
      for (const obs of game.obstacles) {
        const obsX = game.laneWidth * obs.lane + game.laneWidth / 2;
        const dx = Math.abs(playerX - obsX);
        const dy = Math.abs(game.playerY - obs.y);
        if (dx < (playerWidth + obs.width) / 2 && dy < (playerHeight + obs.height) / 2) {
          game.gameOver = true;
          gameState.score = Math.floor(game.score);
          setTimeout(() => exitGame(), 1000);
          return;
        }
      }
      
      // Render
      renderRacingGame();
    }
    
    function renderRacingGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Road
      ctx.fillStyle = '#1e293b';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Road markings
      ctx.strokeStyle = '#00f5d4';
      ctx.lineWidth = 3;
      ctx.setLineDash([30, 25]);
      for (let i = 1; i < racingGame.lanes; i++) {
        const x = racingGame.laneWidth * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      ctx.setLineDash([]);
      
      // Animated road lines
      const lineCount = Math.ceil(canvas.height / 50) + 2;
      for (let i = 0; i < lineCount; i++) {
        const y = (racingGame.roadOffset + i * 50) % (canvas.height + 50) - 50;
        if (y > -20 && y < canvas.height + 20) {
          ctx.fillStyle = '#00f5d4';
          ctx.fillRect(racingGame.laneWidth - 5, y, 10, 20);
          ctx.fillRect(racingGame.laneWidth * 2 - 5, y, 10, 20);
        }
      }
      
      // Player car
      ctx.fillStyle = '#ec4899';
      const playerX = racingGame.laneWidth * racingGame.playerLane + racingGame.laneWidth / 2;
      ctx.fillRect(playerX - 17, racingGame.playerY - 30, 35, 60);
      
      // Rivals
      for (const rival of racingGame.rivals) {
        const rivalX = racingGame.laneWidth * rival.lane + racingGame.laneWidth / 2;
        ctx.fillStyle = rival.color;
        ctx.fillRect(rivalX - 17, rival.y - 30, 35, 60);
      }
      
      // Obstacles
      ctx.fillStyle = '#f87171';
      for (const obs of racingGame.obstacles) {
        const obsX = racingGame.laneWidth * obs.lane + racingGame.laneWidth / 2;
        ctx.fillRect(obsX - obs.width/2, obs.y - obs.height/2, obs.width, obs.height);
      }
      
      // Score
      gameState.score = Math.floor(racingGame.score);
      scoreEl.textContent = gameState.score.toLocaleString();
    }
  </script>
</body>
</html>

