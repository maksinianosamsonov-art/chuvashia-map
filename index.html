<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Dodge: Deluxe</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&display=swap');

        :root {
            --bg-color: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.85);
            --primary: #3b82f6;
            --accent: #f59e0b;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: var(--text-main);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 16px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transition: opacity 0.3s;
        }

        .stat-badge {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 8px 16px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            font-weight: 600;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 900;
            font-variant-numeric: tabular-nums;
        }

        /* SCREENS & CARDS */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; /* Cards at bottom for reachability */
            padding-bottom: 30px;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            transition: opacity 0.4s ease;
            z-index: 20;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .card {
            background: var(--card-bg);
            width: 90%;
            max-width: 400px;
            border-radius: 32px;
            padding: 32px 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            transform: translateY(0);
            animation: slideUp 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
        }

        /* Shine effect */
        .card::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.05), transparent);
            transition: 0.5s;
            pointer-events: none;
        }

        @keyframes slideUp {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .card h1 {
            margin: 0 0 12px 0;
            font-size: 28px;
            font-weight: 900;
            letter-spacing: -0.5px;
            background: linear-gradient(to right, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .card p {
            margin: 0 0 32px 0;
            font-size: 15px;
            line-height: 1.6;
            color: var(--text-muted);
        }

        .btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border: none;
            width: 100%;
            padding: 18px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.3);
            transition: transform 0.1s;
            position: relative;
            overflow: hidden;
        }

        .btn:active { transform: scale(0.97); }

        /* DIALOG LAYOUT */
        .dialog-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .char-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #e2e8f0;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            border: 3px solid rgba(255,255,255,0.2);
        }

        .dialog-name {
            font-size: 12px;
            text-transform: uppercase;
            font-weight: 700;
            color: var(--accent);
            margin-top: 8px;
        }

        .dialog-text {
            font-size: 18px;
            font-weight: 600;
            line-height: 1.4;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top" id="hud" style="opacity: 0;">
            <div class="stat-badge">
                <div class="stat-label">–û—á–∫–∏</div>
                <div class="stat-value" id="score-val">0</div>
            </div>
            <div class="stat-badge">
                <div class="stat-label">–°–∫–æ—Ä–æ—Å—Ç—å</div>
                <div class="stat-value" style="color: var(--accent);"><span id="speed-val">60</span></div>
            </div>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="menu-screen" class="screen">
        <div class="card">
            <h1>–ü–æ –ß—É–≤–∞—à–∏–∏</h1>
            <p>–Ø –û–∫—Å–∞–Ω–∞. –ï–¥—É –≤ –ß–µ–±–æ–∫—Å–∞—Ä—ã –Ω–∞ –≤–∞–∂–Ω—É—é –≤—Å—Ç—Ä–µ—á—É. –ü–æ–º–æ–≥–∏ –º–Ω–µ –ø—Ä–æ—Å–∫–æ—á–∏—Ç—å —á–µ—Ä–µ–∑ —Ç—Ä–∞—Ñ–∏–∫ –∏ –Ω–µ –ø–æ–ø–∞—Å—Ç—å—Å—è –ì–ê–ò—à–Ω–∏–∫–∞–º!</p>
            <button class="btn" id="btn-start">–ü–û–ï–•–ê–õ–ò</button>
        </div>
    </div>

    <!-- DIALOG OVERLAY -->
    <div id="dialog-screen" class="screen hidden">
        <div class="card">
            <div class="dialog-content">
                <div>
                    <div class="char-avatar" id="dialog-icon">üëÆ‚Äç‚ôÇÔ∏è</div>
                    <div class="dialog-name" id="dialog-title">–î–ü–°</div>
                </div>
                <div class="dialog-text" id="dialog-body">
                    –¢–µ–∫—Å—Ç –¥–∏–∞–ª–æ–≥–∞...
                </div>
                <button class="btn" id="btn-dialog-action">–î–µ–π—Å—Ç–≤–∏–µ</button>
            </div>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over-screen" class="screen hidden">
        <div class="card">
            <h1 style="background: linear-gradient(to right, #ef4444, #f87171); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">–î–¢–ü!</h1>
            <p>–≠—Ö, –û–∫—Å–∞–Ω–∞... –ú–∞—à–∏–Ω—É –ø–æ–º—è–ª–∏.</p>
            <div class="stat-badge" style="width: fit-content; margin: 0 auto 30px auto; background: rgba(255,255,255,0.1);">
                <div class="stat-label">–ò—Ç–æ–≥–æ–≤—ã–π —Å—á–µ—Ç</div>
                <div class="stat-value" id="final-score" style="font-size: 32px;">0</div>
            </div>
            <button class="btn" id="btn-restart">–ó–ê–ù–û–í–û</button>
        </div>
    </div>

    <script>
    (function() {
        // --- TG INIT ---
        try { if (window.Telegram?.WebApp) window.Telegram.WebApp.expand(); } catch(e){}

        // --- ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let w, h;
        let animationId;
        let frame = 0;

        // Polyfill for roundRect
        if (!ctx.roundRect) {
            ctx.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x+r, y);
                this.arcTo(x+w, y, x+w, y+h, r);
                this.arcTo(x+w, y+h, x, y+h, r);
                this.arcTo(x, y+h, x, y, r);
                this.arcTo(x, y, x+w, y, r);
                this.closePath();
            };
        }

        // --- STATE ---
        const state = {
            running: false,
            paused: false,
            score: 0,
            speed: 60,
            difficulty: 1,
            laneOffset: 0,
            
            // Story Logic
            lastEventScore: 0,
            eventCooldown: 600, // Points between events
            eventsTriggered: [] // 'batyrevo', 'komso', 'yadrin'
        };

        const player = { x: 0, y: 0, w: 50, h: 100, targetX: 0, lean: 0 };
        let objects = []; 

        const chuvashiaTowns = ['–ß–µ–±–æ–∫—Å–∞—Ä—ã', '–ö–∞–Ω–∞—à', '–®—É–º–µ—Ä–ª—è', '–ê–ª–∞—Ç—ã—Ä—å', '–¶–∏–≤–∏–ª—å—Å–∫', '–ö—É–≥–µ—Å–∏', '–í—É—Ä–Ω–∞—Ä—ã'];

        // --- RENDERERS ---

        function drawOksana(ctx, x, y, w, h, isMenu) {
            const t = frame * 0.1;
            const bounce = isMenu ? Math.sin(t)*3 : Math.sin(t*2)*1;
            y += bounce;

            // –ù–∞–∫–ª–æ–Ω —Ç–µ–ª–∞ –ø—Ä–∏ –ø–æ–≤–æ—Ä–æ—Ç–µ
            const lean = isMenu ? 0 : player.lean * 0.15;

            ctx.save();
            // Pivot at bottom center
            ctx.translate(x + w/2, y + h);
            ctx.rotate(lean);
            ctx.translate(-(x + w/2), -(y + h));

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath(); ctx.ellipse(x+w/2, y+h-5, w/2, 8, 0, 0, Math.PI*2); ctx.fill();

            // Legs (Jeans)
            ctx.fillStyle = '#334155'; // Dark Denim
            // Left
            ctx.beginPath(); ctx.roundRect(x+w*0.15, y+h*0.5, w*0.3, h*0.45, 5); ctx.fill();
            // Right
            ctx.beginPath(); ctx.roundRect(x+w*0.55, y+h*0.5, w*0.3, h*0.45, 5); ctx.fill();
            // Hips
            ctx.beginPath(); ctx.roundRect(x+w*0.15, y+h*0.45, w*0.7, h*0.15, 8); ctx.fill();

            // Boots
            ctx.fillStyle = '#0f172a';
            ctx.beginPath(); ctx.roundRect(x+w*0.12, y+h*0.9, w*0.36, h*0.1, 4); ctx.fill();
            ctx.beginPath(); ctx.roundRect(x+w*0.52, y+h*0.9, w*0.36, h*0.1, 4); ctx.fill();

            // Body (Turtleneck)
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.roundRect(x+w*0.18, y+h*0.18, w*0.64, h*0.32, 10); ctx.fill();
            // Neck
            ctx.beginPath(); ctx.roundRect(x+w*0.35, y+h*0.14, w*0.3, h*0.06, 3); ctx.fill();

            // Arms
            const armSway = isMenu ? Math.sin(t)*2 : -lean * 10;
            ctx.fillStyle = '#111';
            // Left
            ctx.beginPath(); ctx.roundRect(x+w*0.05, y+h*0.19+armSway, w*0.15, h*0.28, 5); ctx.fill();
            // Right
            ctx.beginPath(); ctx.roundRect(x+w*0.8, y+h*0.19-armSway, w*0.15, h*0.28, 5); ctx.fill();
            // Hands
            ctx.fillStyle = '#fde6d3';
            ctx.beginPath(); ctx.arc(x+w*0.12, y+h*0.48+armSway, w*0.06, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(x+w*0.87, y+h*0.48-armSway, w*0.06, 0, Math.PI*2); ctx.fill();

            // Head
            ctx.fillStyle = '#fde6d3';
            ctx.beginPath(); ctx.ellipse(x+w/2, y+h*0.12, w*0.22, h*0.14, 0, 0, Math.PI*2); ctx.fill();

            // Hair (Detailed)
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            // Top volume
            ctx.moveTo(x+w*0.1, y+h*0.1);
            ctx.bezierCurveTo(x+w*0.2, y-h*0.08, x+w*0.8, y-h*0.08, x+w*0.9, y+h*0.1);
            // Right flow
            ctx.bezierCurveTo(x+w*1.15, y+h*0.3, x+w*0.9, y+h*0.5, x+w*1.0, y+h*0.7);
            ctx.lineTo(x+w*0.8, y+h*0.7);
            ctx.bezierCurveTo(x+w*0.7, y+h*0.5, x+w*0.8, y+h*0.3, x+w*0.75, y+h*0.1);
            // Left flow
            ctx.lineTo(x+w*0.25, y+h*0.1);
            ctx.bezierCurveTo(x+w*0.2, y+h*0.3, x+w*0.3, y+h*0.5, x+w*0.2, y+h*0.7);
            ctx.lineTo(x, y+h*0.7);
            ctx.bezierCurveTo(x+w*0.1, y+h*0.5, x-w*0.15, y+h*0.3, x+w*0.1, y+h*0.1);
            ctx.fill();

            // Face (Menu Only)
            if (isMenu) {
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.ellipse(x+w*0.38, y+h*0.12, w*0.06, h*0.025, 0, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(x+w*0.62, y+h*0.12, w*0.06, h*0.025, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#4b3621';
                ctx.beginPath(); ctx.arc(x+w*0.38, y+h*0.12, w*0.03, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(x+w*0.62, y+h*0.12, w*0.03, 0, Math.PI*2); ctx.fill();
                
                // Lips
                ctx.fillStyle = '#be4d25';
                ctx.beginPath(); ctx.ellipse(x+w*0.5, y+h*0.17, w*0.05, h*0.015, 0, 0, Math.PI*2); ctx.fill();
                
                // Blush
                ctx.fillStyle = 'rgba(255, 100, 100, 0.15)';
                ctx.beginPath(); ctx.arc(x+w*0.3, y+h*0.15, w*0.08, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(x+w*0.7, y+h*0.15, w*0.08, 0, Math.PI*2); ctx.fill();
            }

            ctx.restore();
        }

        function drawCar(ctx, o) {
            const {x, y, width, height, color, brand} = o;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.roundRect(x+10, y+10, width, height, 12); ctx.fill();

            // Body
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.roundRect(x, y, width, height, 12); ctx.fill();

            // Cabin
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(x+6, y+20, width-12, 15); // Front glass
            ctx.fillRect(x+6, y+height-30, width-12, 12); // Back glass
            
            // Roof
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.9;
            ctx.fillRect(x+8, y+35, width-16, height-65);
            ctx.globalAlpha = 1.0;

            // Lights
            ctx.fillStyle = '#ef4444'; // Brake lights
            ctx.fillRect(x+4, y+height-5, 10, 4);
            ctx.fillRect(x+width-14, y+height-5, 10, 4);

            // Logo
            const cx = x + width/2;
            const cy = y + height - 20;
            if (brand === 'merc') {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, cy-6); ctx.lineTo(cx, cy); ctx.lineTo(cx-4, cy+3); ctx.moveTo(cx, cy); ctx.lineTo(cx+4, cy+3); ctx.stroke();
            } else if (brand === 'bmw') {
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx, cy, 6, 0, Math.PI/2); ctx.lineTo(cx,cy); ctx.arc(cx,cy,6,Math.PI,Math.PI*1.5); ctx.fill();
            } else {
                ctx.fillStyle = '#fff'; ctx.font = '700 8px Arial'; ctx.textAlign = 'center'; ctx.fillText('LEXUS', cx, cy+3);
            }
        }

        // --- LOGIC ---
        function update() {
            if (state.paused) return;

            frame++;
            state.score++;
            
            // Calc Speed
            let rawSpeed = 60 + Math.floor(state.score / 15);
            
            // STORY TRIGGERS
            if (rawSpeed >= 100) {
                const timeSinceLast = state.score - state.lastEventScore;
                
                // 1. Batyrevo (First 100km/h)
                if (!state.eventsTriggered.includes('batyrevo')) {
                    triggerEvent('batyrevo');
                    return;
                }
                
                // 2. Komso (Grandma) - Needs cooldown
                if (state.eventsTriggered.includes('batyrevo') && 
                    !state.eventsTriggered.includes('komso') && 
                    timeSinceLast > state.eventCooldown) {
                    triggerEvent('komso');
                    return;
                }

                // 3. Yadrin (Final Police) - Needs cooldown after grandma
                if (state.eventsTriggered.includes('komso') && 
                    !state.eventsTriggered.includes('yadrin') && 
                    timeSinceLast > state.eventCooldown) {
                    triggerEvent('yadrin');
                    return;
                }
            }

            state.speed = rawSpeed;
            document.getElementById('speed-val').innerText = state.speed;
            
            if (state.score % 10 === 0) document.getElementById('score-val').innerText = Math.floor(state.score/10);
            
            // Movement
            const diff = player.targetX - player.x;
            player.x += diff * 0.15;
            player.lean = -diff * 0.1;

            // Spawn
            if (Math.random() < 0.02) spawn('car');
            if (Math.random() < 0.05) spawn('tree');
            if (Math.random() < 0.01) spawn('sign');

            // Update entities
            for (let i = objects.length - 1; i >= 0; i--) {
                let o = objects[i];
                o.y += 5 + (state.speed * 0.15); // Base speed + relative speed
                
                if (o.type === 'car') {
                    o.y += o.speed; // Car's own speed
                    // Collision
                    if (rectIntersect(player.x+10, player.y+10, player.w-20, player.h-20, o.x, o.y, o.width, o.height)) {
                        gameOver();
                    }
                }
                if (o.y > h + 100) objects.splice(i, 1);
            }
        }

        function spawn(type) {
            const roadW = w * 0.9;
            const roadX = w * 0.05;
            
            if (type === 'car') {
                const laneCount = 3;
                const laneW = roadW / laneCount;
                const lane = Math.floor(Math.random() * laneCount);
                const x = roadX + lane * laneW + (laneW - 50)/2;
                
                // Check overlap
                for(let o of objects) {
                    if (o.type === 'car' && Math.abs(o.y - (-150)) < 200 && Math.abs(o.x - x) < 50) return;
                }

                const brands = ['merc', 'bmw', 'lexus'];
                const brand = brands[Math.floor(Math.random()*3)];
                let color = '#94a3b8';
                if (brand === 'bmw') color = '#1e293b';
                
                objects.push({type: 'car', x: x, y: -150, width: 50, height: 90, speed: Math.random()*2, color: color, brand: brand});
            } 
            else if (type === 'tree') {
                const side = Math.random() < 0.5 ? 'left' : 'right';
                const x = side === 'left' ? Math.random()*30 - 20 : w - Math.random()*30;
                objects.push({type: 'tree', x: x, y: -50});
            }
            else if (type === 'sign') {
                const x = w * 0.9;
                objects.push({type: 'sign', x: x, y: -50, text: chuvashiaTowns[Math.floor(Math.random()*chuvashiaTowns.length)]});
            }
        }

        function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
        }

        function triggerEvent(id) {
            state.paused = true;
            document.getElementById('dialog-screen').classList.remove('hidden');
            state.eventsTriggered.push(id);
            state.lastEventScore = state.score;

            const icon = document.getElementById('dialog-icon');
            const title = document.getElementById('dialog-title');
            const body = document.getElementById('dialog-body');
            const btn = document.getElementById('btn-dialog-action');

            if (id === 'batyrevo') {
                icon.innerText = 'üëÆ‚Äç‚ôÇÔ∏è';
                title.innerText = '–î–ü–° –ë–ê–¢–´–†–ï–í–û';
                body.innerHTML = '‚Äî –ö—É–¥–∞ –ª–µ—Ç–∏–º, –≥—Ä–∞–∂–¥–∞–Ω–æ—á–∫–∞? –¢—É—Ç –Ω–µ –∞–≤—Ç–æ–±–∞–Ω!';
                btn.innerText = '–ò–∑–≤–∏–Ω–∏—Ç–µ (–®—Ç—Ä–∞—Ñ)';
                btn.onclick = () => resolveEvent('penalty');
            } else if (id === 'komso') {
                icon.innerText = 'üëµ';
                title.innerText = '–ë–ê–ë–£–®–ö–ê (—Å. –ö–æ–º—Å–æ–º–æ–ª—å—Å–∫–æ–µ)';
                body.innerHTML = '‚Äî –í–Ω—É—á–µ–Ω—å–∫–∞, –ø–æ–¥–æ–∂–¥–∏! –í–æ–∑—å–º–∏ –ø–∏—Ä–æ–∂–∫–æ–≤ –≤ –¥–æ—Ä–æ–≥—É!';
                btn.innerText = '–°–ø–∞—Å–∏–±–æ, –∞–ø–∞! (+ –û—á–∫–∏)';
                btn.onclick = () => resolveEvent('bonus');
            } else if (id === 'yadrin') {
                icon.innerText = 'üëÆ‚Äç‚ôÇÔ∏è';
                title.innerText = '–î–ü–° –Ø–î–†–ò–ù';
                body.innerHTML = '‚Äî –û–æ–æ, –û–∫—Å–∞–Ω–∞! –•–∞–º–∞—Ä —è–ª? –ü—Ä–æ–µ–∑–∂–∞–π, –Ω–µ –∑–∞–¥–µ—Ä–∂–∏–≤–∞—é!';
                btn.innerText = '–ú–∞—Ç—Ç—É—Ä! (–ï—Ö–∞—Ç—å)';
                btn.onclick = () => resolveEvent('free');
            }
        }

        function resolveEvent(type) {
            document.getElementById('dialog-screen').classList.add('hidden');
            state.paused = false;
            
            if (type === 'penalty') {
                state.score = Math.max(0, state.score - 400); // Reset speed
            } else if (type === 'bonus') {
                state.score += 500;
            }
            
            // Clear path
            objects = objects.filter(o => o.type !== 'car');
        }

        // --- DRAW LOOP ---
        function loop() {
            // Background
            ctx.fillStyle = '#166534'; // Grass dark
            ctx.fillRect(0,0,w,h);
            
            // Road
            const roadX = w * 0.05;
            const roadW = w * 0.9;
            ctx.fillStyle = '#334155'; ctx.fillRect(roadX, 0, roadW, h);
            
            // Markings
            state.laneOffset = (state.laneOffset + (state.speed * 0.2)) % 60;
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 4;
            ctx.setLineDash([30, 30]);
            ctx.lineDashOffset = -state.laneOffset;
            const laneW = roadW / 3;
            ctx.beginPath();
            ctx.moveTo(roadX + laneW, -50); ctx.lineTo(roadX + laneW, h+50);
            ctx.moveTo(roadX + laneW*2, -50); ctx.lineTo(roadX + laneW*2, h+50);
            ctx.stroke();
            ctx.setLineDash([]);

            // Objects (Sorted by Y)
            const allObjs = [...objects, {type: 'player', y: player.y}];
            allObjs.sort((a,b) => a.y - b.y);

            allObjs.forEach(o => {
                if (o.type === 'tree') {
                    ctx.fillStyle = '#14532d';
                    ctx.beginPath(); ctx.moveTo(o.x, o.y-40); ctx.lineTo(o.x+20, o.y); ctx.lineTo(o.x-20, o.y); ctx.fill();
                } else if (o.type === 'sign') {
                    ctx.fillStyle = '#64748b'; ctx.fillRect(o.x, o.y-30, 4, 30);
                    ctx.fillStyle = '#3b82f6'; ctx.fillRect(o.x-60, o.y-50, 60, 20);
                    ctx.fillStyle = 'white'; ctx.font = '10px Inter'; ctx.fillText(o.text, o.x-55, o.y-36);
                } else if (o.type === 'car') {
                    drawCar(ctx, o);
                } else if (o.type === 'player') {
                    if (state.running) drawOksana(ctx, player.x, player.y, player.w, player.h, false);
                }
            });

            // Menu Animation
            if (!document.getElementById('menu-screen').classList.contains('hidden')) {
                const bigW = Math.min(w * 0.6, 200);
                drawOksana(ctx, (w-bigW)/2, h - bigW*2 - 180, bigW, bigW*2, true);
            }

            animationId = requestAnimationFrame(loop);
        }

        // --- CONTROLS ---
        document.getElementById('btn-start').onclick = () => {
            state.running = true;
            state.score = 0;
            state.eventsTriggered = [];
            state.lastEventScore = 0;
            objects = [];
            
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('hud').style.opacity = 1;
            
            player.targetX = w/2 - player.w/2;
            player.x = player.targetX;
            player.y = h - player.h - 50;
        };

        document.getElementById('btn-restart').onclick = document.getElementById('btn-start').onclick;

        function gameOver() {
            state.running = false;
            document.getElementById('final-score').innerText = Math.floor(state.score/10);
            document.getElementById('hud').style.opacity = 0;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        // Input
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (state.paused) return;
            player.targetX = e.touches[0].clientX - player.w/2;
            // Clamp
            const max = w * 0.95 - player.w;
            const min = w * 0.05;
            if (player.targetX < min) player.targetX = min;
            if (player.targetX > max) player.targetX = max;
        });

        // Init
        window.onresize = () => {
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width = w;
            canvas.height = h;
        };
        window.onresize();
        
        // Expose functions for onclick
        window.gameStart = document.getElementById('btn-start').onclick;
        window.gameRestart = document.getElementById('btn-restart').onclick;
        // Resolve function is global inside closure, need to expose manually if needed, but handled by closures above

        loop();

    })();
    </script>
</body>
</html>
